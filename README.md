
# Назначение
Программы предназначены для симуляции работы TCP- и UDP-клиентов и серверов. Со спецификой работы каждой программы можно ознакомиться в пункте **Задание.**

# Запуск
Для проверки работоспособности программ, написаных для ОС Windows, необходимо:
* скомплировать программу в Visual Studio
* запустить программу в консоли

Для проверки работоспособности программ, написаных для ОС Linux, необходимо:
* перейти в директорию, где лежит файл с программой
* скомпилировать программу и создать объектный файл командой
```
g++-5 tcpclient.cpp -o tcpclient
```
* запустить программу способом, представленным ниже

TCP-клиент разработан для ОС Linux. Команда запуска
```
./tcpclient <addr>:<port> <filename.txt>
```
TCP-сервер разработан для ОС Windows. Как аргумент необходимо передать:
```
<port>
```
UDP-клиент разработан для ОС Windows. Как аргумент необходимо передать:
```
<addr>:<port> <filename.txt>
```
UDP-сервер разработан для ОС Linux
```
./udpserver <port>
```
# Задание
**Часть I. Сетевые взаимодействия с помощью поточных протоколов.**

В системе хранится текстовый файл, в котором записаны некоторые сообщения. Сообщения записаны по одному на строке. Сообщение состоит из нескольких частей, части разделены одним пробелом. В файле могут быть пустые строки, которые должны игнорироваться. 

Задание 1. Необходимо реализовать сетевую программу (tcpclient.cpp), которая считывала бы все эти сообщения из текстового файла и передавала их на удаленный сервер, прослушивающий TCP порт. Протокол взаимодействия клиента и сервера указан в вашем варианте задания.

Адрес и порт сервера, а также имя входного файла указываются как аргументы командной строки при запуске клиента, например:
tcpclient 192.168.50.7:9000 file1.txt
где tcpclient - имя исполняемого бинарного файла клиента (получен путем компиляции tcpclient.cpp), 192.168.50.7 - IPv4 адрес сервера, 9000 - прослушиваемый сервером TCP-порт, file1.txt - файл с сообщениями.

Примечания:
- Клиент должен быть реализован для ОС Linux, будет компилироваться и проверяться компилятором g++ 5.x
- Клиент может распечатывать некоторые отладочные сообщения в stdout, но этим не стоит злоупотреблять: большой stdout не будет сохраняться в результате теста. В stdout рекомендуется распечатывать только важные сообщения, в том числе об ошибках: подключения, неожиданного обрыва связи и т.д. Также stdout не сохраняется, если программа "зависла" и не завершается в течение отведенного ей разумного интервала времени - в этом случае ее аварийно останавливают и тест получает статус "timeout" без сохранения stdout.
- Клиенту не стоит создавать какие-либо посторонние файлы в текущем каталоге, т.к. в тестах будет запускаться несколько экземпляров клиентов и попытки открыть файл с одним и тем же именем в разных экземплярах запущенной программы клинта может порождать конфликты доступа к одному и тому же файлу.
- Если клиенту не удалось подключиться к серверу, то он должен подождать 100 мс и повторить попытку подключения. После 10 неудачных попыток клиент распечатывает ошибку в stdout и завершается.
- Клиент подключается только в начале работы и использует установленное подключение для передачи всех сообщений из файла, т.е. НЕ переподключается к серверу для передачи каждого отдельного сообщения из входного файла.
- Сокет клиента работает в блокирующем режиме.
- Для отладки клиентской программы можно воспользоваться эмулятором сервера: tcpserveremul.rb (Эмулятор сервера написан на ruby, он же будет использоваться системой для тестов вашей клиентской программы. Для запуска сервера необходимо указывать номер прослушиваемого TCP-порта как первый аргумент, например: ruby tcpserveremul.rb 9000).
- Если возникают проблемы с подключениями, то рекомендуется временно, на время разработки, отключить (или добавить используемые порты в исключения) Windows Firewall / iptables и прочих сетевых средств защиты, которые могут блокировать исходящие и входящие сетевые подключения.


Строки исходного файла, считываемый клиентской программой, имеют следующий формат:

dd.mm.yyyy hh:mm:ss +7xxxxxxxxxx Message
dd.mm.yyyy - дата, например 26.04.1985
hh:mm:ss - время, например: 23:14:51
+7xxxxxxxxxx - номер телефона, длина 12, x - цифра 0-9
Message - текст неограниченной длины, до конца строки.
Части записи отделяются друг от друга пробелом (одним).


После успешного подключения клиент отправляет на сервер 3 байта: коды символов 'p', 'u' и 't'. Этим самым он сообщает серверу, что далее будут передаваться сообщения. Далее клиент передает на сервер сообщения, один за одним. Каждое сообщение из исходного файла клиент отправляет на сервер в следующем виде:


Сначала отправляется 4 байта - номер сообщения в исходном файле, целое 32-битное число в СЕТЕВОМ порядке байтов, индексация от 0.
затем значение даты и времени как Unix timestamp, 32-битное беззнаковое число, передается в СЕТЕВОМ порядке байтов;
затем 12 байт - номер телефона, передается как 12 текстовых символов;
затем 4 байта - длина поля Message в символах, unsigned int, в СЕТЕВОМ порядке байтов,
затем N байт - символы самого поля Message.


На каждое принятое сообщение сервер присылает клиенту два байта: коды символов 'o' и 'k'. Это подтверждает успешный прием сообщения сервером. Клиент может и не дожидаться получения "ok" от сервера на каждое сообщение, а отправлять сообщения подряд, а уже после их отправки дождаться от сервера получения нескольких "ok" подряд. Их придет столько же, сколько сообщений отправил клиент.
После передачи последнего сообщения клиент дожидается финального "ok", и завершается. Важно, что клиент НЕ ДОЛЖЕН завершиться раньше, чем получит от сервера подтверждение по последнему сообщению.
Сервер завершается, если клиент отправит на сервер сообщение содержащее в поле Message лишь 4 байта - служебное слово "stop".



**Задание 2. Необходимо реализовать на языке C/C++ сервер tcpserver.cpp, который можно было бы использовать вместо эмулятора (tcpserveremul.rb).**
Сервер должен прослушивать TCP-порт, принимать входящие подключения от клиентов, а затем - принимать сообщения, передаваемые клиентами. На каждое полученное сообщение сервер отправляет клиенту подтверждение "ok", согласно спецификации протокола. Все полученные сообщения сервер распечатывает в файл msg.txt. Каждое сообщение в msg.txt предваряется данными о клиенте: IP-адрес, двоеточие, порт клиента, пробел.
Далее следует сообщение, которое распечатывается в таком же виде, как и было во входном файле клиента. Если от какого-либо клиента пришло сообщение с текстом "stop", то сервер, после отправки этому клиенту подтверждения "ok", закрывает все открытые соединения (отключает всех клиентов) и завершает работу. Номер прослушиваемого порта передается серверу при запуске как первый аргумент командной строки, например: tcpserver 9000 где tcpserver - имя бинарного файла программы, 9000 - номер TCP порта для прослушивания.

Примечания:
- Сокеты сервера работают в неблокирующем режиме.
- Сервер является однопоточной программой. Сервер должен обслуживать несколько одновременно подключенных клиентов.
Механизм параллельного обслуживания: select
- Сервер должен быть реализован для ОС Windows, будет компилироваться и проверяться компилятором Microsoft Visual Studio 2010
- Если при запуске серверу не удалось открыть TCP-порт для прослушивания, то сервер распечатывает сообщение об ошибке в stdout и завершается.
- Сервер может, а вслучае ошибок - и должен, использовать stdout для вывода диагностической информации, но этим, как и в случае с клиентом, не стоит злоупотреблять.
- Номер сообщения, используемый в протоколе, носит только служебный характер и в файле msg.txt не фиксируется.


**Дополнительные задания.
** Реализуйте проверку корректности входных данных. Если формат какого-либо поля в строке исходного файла нарушен, то такая строка игнорируется клиентом и не отправляется на сервер.

** Разработайте программу tcpclient2.cpp, а также внесите изменения в реализацию сервера, чтобы успешно выполнялся следующий сценарий взаимодействия:
Клиент2 запускается следующей командной строкой:
tcpclient2 IP:Port get FILENAME
Клиент2 подключается к серверу, отправляет на него 3 байта: 'g', 'e', 't', что служит для сервера особой командой. При получении такой команды уже сервер пересылает клиенту все сохраненные в msg.txt сообщения, в таком же формате, как указано в спецификации протокола, (включая служебный номер сообщения в начале). IP и port, которые предваряли сообщение в msg.txt сервера игнорируются и не передаются. После передачи последнего сообщения сервер отключает клиента. Если в msg.txt сообщений не было, то клиент будет отключен сразу же.
Клиент сохраняет принимаемые сообщения в файл FILENAME, имя которого передано во втором аргументе аргументе командной строки.
Каждое сообщение, сохраняемое клиентом, предваряется IP-адресом сервера, двоеточие, TCP порт, пробел. Номер сообщения в файле не фиксируется.
Клиент2 реализуется для той же ОС, что и Клиент1.
**Часть II. Сетевые взаимодействия с помощью дейтаграммных протоколов.**

**Задание 1. Реализуйте программу udpclient.cpp, взаимодействующую с удаленным сервером по протоколу UDP.**
 Программа запускается аналогично tcpclient, с указанием IP-адреса и порта удаленного сервера (но уже UDP-порта) и имени входного файла с сообщениями:
udpclient 192.168.50.7:8700 file1.txt

Программа считывает данные из входного файла и на каждую непустую строку формирует сообщение-дейтаграмму и отправляет ее на удаленный сервер. Дейтаграмма содержит данные в таком же формате, в каком tcpclient передавал на удаленный TCP-сервер, т.е. сначала следуют 4 байта с номером сообщение в сетевом порядке и т.д. (см. спецификацию протокола). В одной дейтаграмме передается только одно сообщение.
В ответ на дейтаграмму от клиента сервер посылает клиенту дейтаграмму, содержащую 4-байтовые номера (в сетевом порядке) нескольких последних (не более 20) принятых сообщений. Номера записаны в теле дейтаграммы подряд как 32-битные числа.
Клиент должен повторять отправку дейтаграмм с сообщениями до тех пор, пока на сервер не будут загружены хотя бы 20 ЛЮБЫХ сообщений из исходного файла (Если в исходном файле хранится менее 20 сообщений, то на сервер должны быть отправлены ВСЕ сообщения).

Если от сервера поступила дайтаграмма-подтверждение, то клиент должен проанализировать полученную дейтаграмму и извлечь из нее номера сообщений. Клиент НЕ ДОЛЖЕН ПОВТОРНО посылать те сообщения, которые, по информации клиента, уже находятся на сервере.

Если от сервера не поступало никаких дейтаграмм в течение 100 мс, то клиент повторяет отправку сообщений, но только тех, которые, по его информации, отсутствуют на сервере.
Примечания:
- UDP-клиент реализуется для ОС: Windows
- Сокет клиента работает в блокирующем режиме. Для проверки наличия дейтаграмм во входном буфере можно использовать select().
- Клиент открывает сокет один раз, при запуске и не открывает никаких других UDP-сокетов. Для приема-передачи дейтаграмм используется только один сокет.
- Для отладки клиента можно использовать сервер-эмулятор: udpservemul.rb.


**Задание 2. Реализуйте udpserver.cpp, который можно было бы использовать вместо Ruby-сервера-эмулятора.**

Примечания:
- Сервер реализуется для ОС: Linux
- Сервер прослушивает диапазон UDP-портов (несколько портов, чьи номера идут подряд). Первый и последний номер диапазона указываются как аргументы командной строки при запуске, например: udpserv 9001 9006
- UDP-сокеты сервера работают в неблокирующем режиме. Механизм параллельного обслуживания сокетов: poll
- Клиенты могут отправлять дейтаграммы на любые прослушиваемые сервером порты. Одновременно может отправляться несколько дейтаграмм от разных клиентов.
- Сервер сохраняет принятые сообщения в msg.txt (формат аналогичен tcpserver). Сервер должен обеспечивать отсутствие повторов в выходном файле. Повторами считаются сообщения с одинаковым номером (передается в начале дейтаграммы). Если взять два сообщения с разным номером, то их нужно считать разными, даже если все данные в сообщениях одинаковы. Порядок записи сообщений в msg.txt не имеет значения (допустим любой порядок).
- Если на сервер приходит сообщение с полем Message со значением stop (от любого из клиентов), то сервер, отправив клиенту подтверждение, завершается.
- Идентификатором клиента (ID) можно считать пару: IP-адрес+порт, с которого он отправляет дейтаграммы. Сервер хранит в памяти небольшую базу данных, содержащую информацию: ID клиента и номера принятых от него сообщений. На основании этих данных сервер может формировать ответы клиентам, а также проверять приходящие сообщения на повторность.
- **Если от клиента с определенным ID не поступало сообщений в течение последних 30 секунд, то информация о таком клиенте удаляется из базы.
